(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{428:function(t,a,_){"use strict";_.r(a);var v=_(2),e=Object(v.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"_1-创建索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-创建索引"}},[t._v("#")]),t._v(" 1 创建索引")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("CREATE INDEX idx_name ON students (name);\n")])])]),a("h3",{attrs:{id:"_2-利用索引查询"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-利用索引查询"}},[t._v("#")]),t._v(" 2 利用索引查询")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("SELECT * FROM students WHERE name = 'Alice';\n")])])]),a("h3",{attrs:{id:"_3索引有什么用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3索引有什么用"}},[t._v("#")]),t._v(" 3索引有什么用？")]),t._v(" "),a("blockquote",[a("p",[t._v("MySQL索引是用于提高数据库查询性能的一种数据结构。它们可以加速数据的检索过程，减少数据库的I/O操作，并提高查询效率。以下是索引的几个主要作用：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("快速数据检索：索引允许数据库快速定位符合查询条件的数据行，而无需逐行扫描整个表。通过使用索引，数据库可以直接跳过大量的数据行，提高查询效率。")])]),t._v(" "),a("li",[a("p",[t._v("数据排序：索引可以帮助数据库对数据进行排序。当查询需要按特定列进行排序时，如果有相应的索引，数据库可以利用索引的排序顺序，避免在内存中进行大量的排序操作。")])]),t._v(" "),a("li",[a("p",[t._v("加速连接操作：当进行连接（JOIN）操作时，索引可以加速数据的连接过程。通过在连接列上创建索引，数据库可以更快地找到匹配的数据行，从而提高连接查询的性能。")])]),t._v(" "),a("li",[a("p",[t._v("约束数据唯一性：通过在列上创建唯一索引或主键索引，可以强制保证数据的唯一性。这样可以防止重复的数据被插入，确保数据的完整性和一致性。")])])]),t._v(" "),a("p",[t._v("需要注意的是，虽然索引提供了很多好处，但也会带来一些额外的开销。维护索引会占用存储空间，并在插入、更新和删除操作时需要额外的处理时间。因此，在设计索引时需要权衡查询性能的提升和额外开销之间的关系。")]),t._v(" "),a("p",[t._v("正确的索引设计是优化数据库性能的关键。根据具体的查询需求和数据访问模式，选择合适的列创建索引，可以有效提高查询效率和系统的整体性能。")])]),t._v(" "),a("h3",{attrs:{id:"_4-索引提高查询速度原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-索引提高查询速度原理"}},[t._v("#")]),t._v(" 4 索引提高查询速度原理")]),t._v(" "),a("blockquote",[a("p",[t._v("索引提升查询效率的原理是通过创建一个额外的数据结构，使得数据库可以更快速地定位和访问满足查询条件的数据行，而无需逐行扫描整个表。")]),t._v(" "),a("p",[t._v("具体来说，当在某列上创建索引时，数据库会将索引结构与该列的值进行关联，形成一种键值对的映射关系。这个映射关系可以是树状结构（如B树或B+树）或哈希结构，具体取决于索引的类型。")]),t._v(" "),a("p",[t._v("当执行查询操作时，数据库会利用索引的结构进行快速的定位和搜索，而不是从头开始逐行扫描整个表。数据库会根据查询条件中的列值，通过索引结构快速定位到满足条件的数据行所在的位置，然后获取相应的数据行。")]),t._v(" "),a("p",[t._v("索引的作用类似于字典的目录页，通过快速查找目录页上的关键字（索引键），可以迅速找到目标内容所在的页码（数据行），从而提高检索效率。")]),t._v(" "),a("p",[t._v("索引提升查询效率的关键在于减少了数据库的I/O操作。相比于逐行扫描整个表，使用索引可以更快速地定位到目标数据行，减少了对磁盘读取的次数，从而提高了查询的速度。")]),t._v(" "),a("p",[t._v("然而，索引也需要占用额外的存储空间，并且在插入、更新和删除操作时需要维护索引结构，因此索引的创建和维护会带来一定的开销。因此，在设计索引时需要权衡查询性能的提升和额外开销之间的关系，选择适当的列和索引类型来优化查询效率。")])]),t._v(" "),a("h3",{attrs:{id:"_5-b树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-b树"}},[t._v("#")]),t._v(" 5 B树")]),t._v(" "),a("blockquote",[a("p",[t._v("B树（B-tree）是一种自平衡的树状数据结构，常用于数据库索引的实现。它的原理是通过将数据按照一定规则组织成多层的树结构，从而提供高效的数据插入、查找和删除操作。")]),t._v(" "),a("p",[t._v("B树的特点和原理如下：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("多叉树结构：B树是一种多叉树，每个节点可以包含多个子节点。这使得B树能够存储大量的键值对，并且可以保持树的平衡性。")])]),t._v(" "),a("li",[a("p",[t._v("有序性：B树中的节点按照键值的大小有序排列。对于每个节点，它的左子树的所有键值都小于节点的键值，而右子树的所有键值都大于节点的键值。")])]),t._v(" "),a("li",[a("p",[t._v("平衡性：B树的所有叶子节点位于同一层级，这保证了查询操作的效率。通过调整节点的分裂和合并，B树可以自动保持平衡，避免出现极端不平衡的情况。")])]),t._v(" "),a("li",[a("p",[t._v("节点的填充：为了提高空间利用率，B树的节点可以存储多个键值对。节点中的键值按序排列，并且与子节点相关联。这样可以减少磁盘I/O操作，提高查询效率。")])])]),t._v(" "),a("p",[t._v("通过利用B树的特点，数据库可以将索引数据存储在磁盘上，并利用B树的结构进行高效的索引查找。在查询过程中，数据库可以从根节点开始，按照键值的大小逐层向下查找，直到找到匹配的键值或确定不存在。")]),t._v(" "),a("p",[t._v("B树的平衡性和节点的填充保证了查询操作的效率，并且可以处理大量数据。当插入或删除数据时，B树会进行节点的分裂或合并操作，以保持树的平衡性，并避免过度膨胀或过度收缩。")]),t._v(" "),a("p",[t._v("总结而言，B树作为索引的原理是通过多层的自平衡树结构，按序存储键值对，并利用节点的填充和平衡操作，提供高效的数据插入、查找和删除操作。这使得B树成为数据库索引的常用数据结构，用于优化查询性能。")])]),t._v(" "),a("h4",{attrs:{id:"相关数据结构源码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相关数据结构源码"}},[t._v("#")]),t._v(" 相关数据结构源码")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/lichengcan/data-code",target:"_blank",rel:"noopener noreferrer"}},[t._v("数据结构Java实现"),a("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=e.exports}}]);